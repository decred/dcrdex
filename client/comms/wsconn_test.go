package comms

import (
	"bytes"
	"context"
	"crypto/elliptic"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"testing"
	"time"

	"github.com/decred/dcrd/certgen"
	"github.com/decred/dcrdex/server/comms/msgjson"
	"github.com/gorilla/websocket"
)

func makeRequest(id uint64, route string, msg interface{}) *msgjson.Message {
	req, _ := msgjson.NewRequest(id, route, msg)
	return req
}

// genCertPair generates a key/cert pair to the paths provided.
func genCertPair(certFile, keyFile string, altDNSNames []string) error {
	log.Infof("Generating TLS certificates...")

	org := "dcrdex autogenerated cert"
	validUntil := time.Now().Add(10 * 365 * 24 * time.Hour)
	cert, key, err := certgen.NewTLSCertPair(elliptic.P521(), org,
		validUntil, altDNSNames)
	if err != nil {
		return err
	}

	// Write cert and key files.
	if err = ioutil.WriteFile(certFile, cert, 0644); err != nil {
		return err
	}
	if err = ioutil.WriteFile(keyFile, key, 0600); err != nil {
		os.Remove(certFile)
		return err
	}

	log.Infof("Done generating TLS certificates")
	return nil
}

func TestWsConn(t *testing.T) {
	upgrader := websocket.Upgrader{}
	pingCh := make(chan struct{})
	readPumpCh := make(chan interface{})
	writePumpCh := make(chan *msgjson.Message)
	ctx, cancel := context.WithCancel(context.Background())

	handler := func(w http.ResponseWriter, r *http.Request) {
		c, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			t.Fatalf("unable to upgrade http connection: %s", err)
		}

		defer c.Close()

		go func() {
			for {
				select {
				case <-pingCh:
					err = c.WriteControl(websocket.PingMessage, []byte{},
						time.Time{})
					if err != nil {
						fmt.Printf("unable to write ping: %v", err)
						return
					}

				case msg := <-readPumpCh:
					err := c.WriteJSON(msg)
					if err != nil {
						fmt.Printf("unable to write message: %v", err)
						return
					}

				case <-ctx.Done():
					c.Close()
					return
				}
			}
		}()

		for {
			mType, message, err := c.ReadMessage()
			if err != nil {
				if opErr, ok := err.(*net.OpError); ok {
					if opErr.Op == "read" {
						return
					}
				}

				if websocket.IsCloseError(err) {
					return
				}

				if nErr, ok := err.(net.Error); ok {
					if nErr.Timeout() {
						return
					}
				}

				log.Errorf("unable to read message: %v", err)
				return
			}

			if mType == websocket.TextMessage {
				msg, err := msgjson.DecodeMessage(message)
				if err != nil {
					fmt.Printf("unable to decode msg: %v", err)
					return
				}

				writePumpCh <- msg
			}
		}

	}

	certFile, err := ioutil.TempFile("", "certfile")
	if err != nil {
		t.Fatalf("unable to create temp certfile: %s", err)
	}
	certFile.Close()
	defer os.Remove(certFile.Name())

	keyFile, err := ioutil.TempFile("", "keyfile")
	if err != nil {
		t.Fatalf("unable to create temp keyfile: %s", err)
	}
	keyFile.Close()
	defer os.Remove(keyFile.Name())

	err = genCertPair(certFile.Name(), keyFile.Name(), nil)
	if err != nil {
		t.Fatal(err)
	}

	host := "127.0.0.1:6060"
	http.HandleFunc("/ws", handler)

	go func() {
		err = http.ListenAndServeTLS(host, certFile.Name(), keyFile.Name(), nil)
		if err != nil {
			fmt.Println(err)
		}
	}()

	cfg := &WsCfg{
		Host:               host,
		Path:               "ws",
		PingWait:           3 * time.Second,
		WriteWait:          3 * time.Second,
		RpcCert:            certFile.Name(),
		RpcKey:             keyFile.Name(),
		InsecureSkipVerify: true,
		Ctx:                ctx,
		Cancel:             cancel,
	}
	wsc, err := NewWsConn(cfg)
	if err != nil {
		t.Fatal(err)
	}

	wsc.Run()

	go func() {
		wsc.WaitForShutdown()
	}()

	// Drop the connection and force a reconnect by waiting.
	time.Sleep(time.Millisecond * 3500)

	// Wait for a reconnection.
	for !wsc.isConnected() {
		continue
	}

	// Send a ping.
	pingCh <- struct{}{}

	orderid, _ := msgjson.BytesFromHex("ceb09afa675cee31c0f858b94c81bd1a4c2af8c5947d13e544eef772381f2c8d")
	matchid, _ := msgjson.BytesFromHex("7c6b44735e303585d644c713fe0e95897e7e8ba2b9bba98d6d61b70006d3d58c")
	match := &msgjson.Match{
		OrderID:  orderid,
		MatchID:  matchid,
		Quantity: 20,
		Rate:     2,
		Address:  "DsiNAJCd2sSazZRU9ViDD334DaLgU1Kse3P",
		Time:     1570704776,
	}

	// Ensure a malformed message to the client does not terminate
	// the connection.
	readPumpCh <- []byte("{notjson")

	// Send a message to the client.
	sent := makeRequest(1, msgjson.MatchRoute, match)
	readPumpCh <- sent

	// Fetch the read source.
	readSource := wsc.FetchReadSource()
	if readSource == nil {
		t.Fatal("expected a non-nil read source")
	}

	// Ensure th read source can be fetched once.
	rSource := wsc.FetchReadSource()
	if rSource != nil {
		t.Fatal("expected a nil read source")
	}

	// Read the message received by the client.
	received := <-readSource

	// Ensure the received message equal to the sent message.
	if received.Type != sent.Type {
		t.Fatalf("expected %v type, got %v", sent.Type, received.Type)
	}

	if received.Route != sent.Route {
		t.Fatalf("expected %v route, got %v", sent.Route, received.Route)
	}

	if received.ID != sent.ID {
		t.Fatalf("expected %v id, got %v", sent.ID, received.ID)
	}

	if !bytes.Equal(received.Payload, sent.Payload) {
		t.Fatal("sent and received payload mismatch")
	}

	// Drop the connection and force a reconnect by waiting.
	time.Sleep(time.Millisecond * 3500)

	// Wait for a reconnection.
	for !wsc.isConnected() {
		continue
	}

	// Send a ping.
	pingCh <- struct{}{}

	contract, _ := msgjson.BytesFromHex("caf8d277f80f71e4")
	init := &msgjson.Init{
		OrderID:  orderid,
		MatchID:  matchid,
		TxID:     "c3161033de096fd74d9051ff0bd99e359de35080a3511081ed035f541b850d43",
		Vout:     10,
		Time:     1570704776,
		Contract: contract,
	}

	// Send a message from the client.
	id := wsc.NextID()
	sent = makeRequest(id, msgjson.InitRoute, init)
	err = wsc.SendMessage(sent)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Read the message received by the server.
	received = <-writePumpCh

	// Ensure the received message equal to the sent message.
	if received.Type != sent.Type {
		t.Fatalf("expected %v type, got %v", sent.Type, received.Type)
	}

	if received.Route != sent.Route {
		t.Fatalf("expected %v route, got %v", sent.Route, received.Route)
	}

	if received.ID != sent.ID {
		t.Fatalf("expected %v id, got %v", sent.ID, received.ID)
	}

	if !bytes.Equal(received.Payload, sent.Payload) {
		t.Fatal("sent and received payload mismatch")
	}

	// Drop the connection and force a reconnect by waiting.
	time.Sleep(time.Millisecond * 350)

	// Wait for a reconnection.
	for !wsc.isConnected() {
		continue
	}

	// Send a ping.
	pingCh <- struct{}{}

	// Ensure the next id is as expected.
	next := wsc.NextID()
	if next != 2 {
		t.Fatalf("expected next id to be %d, got %d", 2, next)
	}

	// Ensure the request sent got logged.
	req, err := wsc.FetchRequest(id)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if req.Route != sent.Route {
		t.Fatalf("expected %s route, got %s", sent.Route, req.Route)
	}

	// Lookup an unlogged request id.
	_, err = wsc.FetchRequest(next)
	if err == nil {
		t.Fatal("expected an error for unlogged id")
	}

	// Set the connected state to false and try sending a message.
	wsc.setConnected(false)

	err = wsc.SendMessage(sent)
	if err == nil {
		t.Fatalf("expected a connection state error")
	}

	// Terminate the connection and shutdown
	cancel()
	time.Sleep(time.Second * 2)
}
