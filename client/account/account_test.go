package account

import (
	"bytes"
	"encoding/hex"
	"testing"

	"github.com/decred/dcrdex/server/account"
)

func TestNew(t *testing.T) {
	acc, err := New()
	if err != nil {
		t.Errorf("[New] unexpected error %v", err)
	}

	if acc.PrivKey == nil {
		t.Error("[New] account private key is nil")
	}

	if len(acc.ID[:]) != account.HashSize {
		t.Errorf("[New] expected id length of %d, got %d", account.HashSize,
			len(acc.ID[:]))
	}
}

func TestNewAccountFromPrivKey(t *testing.T) {
	tests := []struct {
		privK   []byte
		wantErr bool
	}{
		{
			privK: []byte{0xa2, 0x6f, 0xe6, 0x50, 0xff, 0xbc, 0xb6, 0xf7,
				0x76, 0x0e, 0x66, 0x22, 0x22, 0xbf, 0x05, 0xd1, 0xdf, 0xa0,
				0x70, 0x36, 0x63, 0x55, 0xd0, 0x45, 0xb7, 0xb9, 0xe8, 0x2e,
				0xde, 0x1f, 0x4e, 0x74},
			wantErr: false,
		},
		{
			privK:   []byte{},
			wantErr: true,
		},
		{
			privK: []byte{0xa2, 0x6f, 0xe6, 0x50, 0xff, 0xbc, 0xb6, 0xf7,
				0x76, 0x0e, 0x66, 0x22, 0x22, 0xbf, 0x05, 0xd1, 0xdf, 0xa0,
				0x70, 0x36, 0x63, 0x55, 0xd0, 0x45, 0xb7, 0xb9, 0xe8, 0x2e,
				0xde, 0x1f, 0x4e},
			wantErr: true,
		},
	}

	for idx, tc := range tests {
		_, err := NewAccountFromPrivKey(tc.privK)
		if (err != nil) != tc.wantErr {
			t.Errorf("[NewAccountFromPrivKey] #%d: error: %v, wantErr: %v",
				idx+1, err, tc.wantErr)
		}
	}
}

func TestSign(t *testing.T) {
	tests := []struct {
		privK       []byte
		sig         []byte
		wantErr     bool
		initAccount bool
		sigMismatch bool
	}{
		{
			privK: []byte{0xa2, 0x6f, 0xe6, 0x50, 0xff, 0xbc, 0xb6, 0xf7,
				0x76, 0x0e, 0x66, 0x22, 0x22, 0xbf, 0x05, 0xd1, 0xdf, 0xa0,
				0x70, 0x36, 0x63, 0x55, 0xd0, 0x45, 0xb7, 0xb9, 0xe8, 0x2e,
				0xde, 0x1f, 0x4e, 0x74},
			sig: []byte{0x30, 0x44, 0x02, 0x20, 0x3c, 0xcc, 0x30, 0xf8,
				0x4f, 0xa7, 0x26, 0x28, 0xd7, 0x2d, 0x8b, 0x34, 0x05, 0x64,
				0x16, 0x85, 0xd7, 0x9c, 0x5f, 0x54, 0x45, 0x8f, 0x16, 0x3d,
				0xc6, 0x0b, 0xb0, 0x38, 0x41, 0xd6, 0xc8, 0xc9, 0x02, 0x20,
				0x67, 0x3f, 0x94, 0x3c, 0xfd, 0xd4, 0x5f, 0xf5, 0xac, 0xa7,
				0x74, 0x1c, 0xcc, 0x0f, 0xe6, 0x42, 0x29, 0x0a, 0x5d, 0xa1,
				0xc2, 0x8e, 0x79, 0x78, 0xa0, 0xe1, 0x5f, 0xa5, 0xa9, 0x13,
				0x7e, 0xff},
			wantErr:     false,
			initAccount: true,
			sigMismatch: false,
		},
		{
			privK: []byte{0xa2, 0x6f, 0xe6, 0x50, 0xff, 0xbc, 0xb6, 0xf7,
				0x76, 0x0e, 0x66, 0x22, 0x22, 0xbf, 0x05, 0xd1, 0xdf, 0xa0,
				0x70, 0x36, 0x63, 0x55, 0xd0, 0x45, 0xb7, 0xb9, 0xe8, 0x2e,
				0xde, 0x1f, 0x4e, 0x74},
			sig:         []byte{},
			wantErr:     false,
			initAccount: true,
			sigMismatch: true,
		},
		{
			privK: []byte{0xa2, 0x6f, 0xe6, 0x50, 0xff, 0xbc, 0xb6, 0xf7,
				0x76, 0x0e, 0x66, 0x22, 0x22, 0xbf, 0x05, 0xd1, 0xdf, 0xa0,
				0x70, 0x36, 0x63, 0x55, 0xd0, 0x45, 0xb7, 0xb9, 0xe8, 0x2e,
				0xde, 0x1f, 0x4e, 0x74},
			sig: []byte{0x30, 0x44, 0x02, 0x20, 0x3c, 0xcc, 0x30, 0xf8,
				0x4f, 0xa7, 0x26, 0x28, 0xd7, 0x2d, 0x8b, 0x34, 0x05, 0x64,
				0x16, 0x85, 0xd7, 0x9c, 0x5f, 0x54, 0x45, 0x8f, 0x16, 0x3d,
				0xc6, 0x0b, 0xb0, 0x38, 0x41, 0xd6, 0xc8, 0xc9, 0x02, 0x20,
				0x67, 0x3f, 0x94, 0x3c, 0xfd, 0xd4, 0x5f, 0xf5, 0xac, 0xa7,
				0x74, 0x1c, 0xcc, 0x0f, 0xe6, 0x42, 0x29, 0x0a, 0x5d, 0xa1,
				0xc2, 0x8e, 0x79, 0x78, 0xa0, 0xe1, 0x5f, 0xa5, 0xa9, 0x13,
			},
			wantErr:     false,
			initAccount: true,
			sigMismatch: true,
		},
		{
			privK: []byte{},
			sig: []byte{0x30, 0x44, 0x02, 0x20, 0x3c, 0xcc, 0x30, 0xf8,
				0x4f, 0xa7, 0x26, 0x28, 0xd7, 0x2d, 0x8b, 0x34, 0x05, 0x64,
				0x16, 0x85, 0xd7, 0x9c, 0x5f, 0x54, 0x45, 0x8f, 0x16, 0x3d,
				0xc6, 0x0b, 0xb0, 0x38, 0x41, 0xd6, 0xc8, 0xc9, 0x02, 0x20,
				0x67, 0x3f, 0x94, 0x3c, 0xfd, 0xd4, 0x5f, 0xf5, 0xac, 0xa7,
				0x74, 0x1c, 0xcc, 0x0f, 0xe6, 0x42, 0x29, 0x0a, 0x5d, 0xa1,
				0xc2, 0x8e, 0x79, 0x78, 0xa0, 0xe1, 0x5f, 0xa5, 0xa9, 0x13,
				0x7e, 0xff},
			wantErr:     true,
			initAccount: false,
			sigMismatch: true,
		},
	}

	for idx, tc := range tests {
		var err error
		var acc *Account

		if tc.initAccount {
			acc, err = NewAccountFromPrivKey(tc.privK)
			if err != nil {
				t.Fatalf("[Sign] #%d: unexpected error: %v",
					idx+1, err)
			}
		} else {
			acc = &Account{}
		}

		msg := []byte("test")
		sig, err := acc.Sign(msg)
		if (err != nil) != tc.wantErr {
			t.Fatalf("[Sign] #%d: error: %v, wantErr: %v",
				idx+1, err, tc.wantErr)
		}

		if !bytes.Equal(sig, tc.sig) != tc.sigMismatch {
			t.Errorf("[Sign] %d: expected sig %v, got %v", idx,
				hex.EncodeToString(sig), hex.EncodeToString(tc.sig))
		}
	}
}
